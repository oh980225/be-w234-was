# java-was-2022

## Java Web Application Server 2022

### 강의1
* Thread는 각각 별도의 레지스터, Stack을 따로 할당 받는다.

* Thread는 CPU에서 실행되는데, 이 별도의 공간을 이용하여 컨텍스트 스위칭이 가능한 것이다.

* 하지만 Heap Area와 Method Area는 공유하여 사용한다.

* 자바에서 Thread는 메서드 단위로 수행된다.

* 해당 과제에서의 요청 흐름 
  1. 서버 소켓 생성
  2. 서버 소켓 요청 대기
  3. 클라이언트 요청
  4. 커넥션 소켓 생성 (별도의 포트 할당)
  5. 해당 소켓을 통해 클라이언트의 요청을 처리하는 워커 쓰레드 생성
  6. 워커 쓰레드를 통해 작업 수행 및 응답

* 이번 단계를 구현하며 한 생각 정리
  * HttpMethod와 프로토콜은 상수라고 생각하여 enum으로 뽑아내었다.
  * url같은 경우, 상수로 지정하기 어렵고 아직 불변식이라고 할만한 부분이 없어서 우선 String을 사용하였다.
  * String 값에 대해 null 또는 빈 값인 경우, 예외를 발생하게 해놓은 코드는 범용적으로 사용하게 된다면 Util 클래스를 만들어 옮길 것 같다.
  * 웹 서버 동작 중 발생할 수 있는 예외에 대해 Custom Exception class를 만들었다. 각 경우에 대해 따로 클래스를 만들게 되면 상당한 양의 예외 클래스가 생길 것이라 판단하여 하나의 예외 클래스에서 사용되는 다양한 에러 메시지를 Enum으로 사용하도록 하였다.

### 강의2
* 커밋은 작게 원자 단위로 하자! (메서드 단위가 베스트)

* reset은 기록이 안남지만, revert는 기록이 쌓인다! 그렇기에 가능하면 풍부한 기록을 남기는 revert가 더 좋다!

* TDD -> test code를 먼저 짜고 구현 시작!
  * 보통 익숙하지 않으면 코드를 먼저 짜고 테스트 코드를 작성한다.
  * 연습을 위해 위처럼하고 구현 코드를 날려보고, 다시 구현하는 것도 괜찮다.

* Git commit을 이용해서 구현 전에 상세한 커밋을 작성하고, 계획적으로 코딩하는 방법도 있다.

* 주석은 최소한으로! 주석이 없이 이해가 가능한 코드가 더 좋은 코드다!

* UDP는 IP에서 그냥 플러스 알파이다. 대신 속도가 엄청 빠르고, 커스터마이징할 것이 많다.

* 요즘은 그냥 실시간 채팅 같은 경우도 TCP를 사용한다.

* 하지만 TCP 같은 경우는 이거저거 다 붙혀놓아 코스트가 크기 때문에, 속도를 위해 UDP를 기반으로 커스터마이징 해서 사용하기도 한다.
  * HTTP 3 같은 경우에도 UDP를 기반으로 만들 계획이라고 한다.

### 강의3
* MIME -> 클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘. 서버는 각 문서와 함께 올바른 MIME 타입을 보내주는 것이 중요하다.

* 리다이렉트 수행 : 서버에서 302를 준다. -> 브라우저가 리다이렉트를 수행한다.(실제 액션)

* 쿠키 : 서버에서 Set-Cookie를 보내면, 클라이언트에서 쿠키를 만들고 보관 -> 다음 요청부터 쿠키를 요청에 담아서 보낸다.

* 브라우저가 쿠키를 저장하는 방법 : 크롬 같은 경우, 내부적인 조그만 DB에 저장(ex) SQLLite)

* DB 관련
```markdown
- PK는 자동으로 인덱스가 만들어진다.
 
- 인덱스를 통해서 검색속도를 향상시킬 수있다.

- 인덱스는 B+Tree 자료구조를 사용한다.

- B+Tree는 범위 검색에 강하다.

- 테이블은 페이지로 구성되어있다.

- 페이지 내에 레코드들이 쌓여있다. 한 페이지는 보통 16KB로 되어있다.

- 레코드들은 특정 key 값으로 정렬되어있다. (PK 값)

- 클러스터 인덱스 : PK에 대해 B+Tree 인덱스가 구성되어있고 이 B+Tree의 리프노드가 페이지 내에 
  쌓여있는 레코드에 대해 해당하는 데이터 포인터를 가지고 있는 것! 자료구조를 뜻하는 것이 아니다.
  
- 쿼리가 느릴 때 가장 먼저 해볼 수 있는 시도는 인덱스를 만드는 것이다.

- MySQL은 내부적으로 통계 정보를 가지고 있다. 각 데이터가 어느정도 분포되어있는지 알고 있다. 
  이것을 이용해 쿼리 플랜을 세운다.
  
- 왜 인덱스가 있어도 탈 때도 있고, 안 탈때도 있을까? 
  -> 인덱스를 타는 비용은 [인덱스를 찾는 비용 + 각각의 포인터를 통해 원하는 데이터를 찾아가는 비용]이다.
  풀스캔은 [데이터 페이지를 그냥 쭈욱 읽는 비용]이 든다. 그렇기에 인덱스를 탄다고 항상 빠른 것은 아니다!  
  옵티마이저가 각 경우에 대한 비용을 산정하여 가장 효율적인 방식을 고른다. 일반적으로 전체페이지 중 
  20%이상을 검색하면 옵티마이저로 인해 인덱스를 안탄다.(이것이 더 효율적이므로!)
  
- 복합인덱스를 만들때는 컬럼의 순서가 중요하다!
```

### 강의4
* DB의 락은 테이블, 칼럼, 레코드, 인덱스, 특정 범위에도 걸 수 있다.

* MySQL의 기본 스토리지 엔진은 InnoDB이다.

* 스토리지 엔진은 다른 것도 존재하고 변경할 수 있다.

* InnoDB는 레코드 기반 저장구조이다.

* Amazon의 RedShift같은 경우는 column store이다. 그렇기에 통계를 내는 것에는 더 효율적이다.

* Secondary Index는 PK를 참조한다.

* 레코드 기반 잠금을 지원하지만 실제 물리적 잠금은 인덱스에 걸린다.

* 트랜잭셕의 성질은 ACID가 있다.

* 추가적으로 분산시스템의 기본 성질인 CAP이론이라는 것이 있다.
```markdown
- C(Consistency) : 일관성
- A(Availability : 가용성
- P(Partition tolerance) : 분단 허용성
```

* CAP를 모두 만족시키는 시스템은 구현할 수 없다. 많은 NoSQL은 일관성을 포기한다.

* Optimistic Concurrency Control VS Pessimistic Lock
  * **Optimistic Concurrency Control** : 여러 트랜잭션이 서로 간섭하지 않고 자주 완료될 수 있다고 가정. 트랜잭션은 해당 리소스에 대한 잠금을 획득하지 않고 데이터 리소스를 사용. 처리량이 높아진다는 장점이 있으나 리소스 경합이 빈번해 질경우 문제 발생
  * **Pessimistic Lock** : 해당 리소스에 대한 잠금을 획득하여 데이터 리소스를 사용. 위 낙관적 동시성 제어보다는 처리량이 낮지만, 리소스 경합으로 인한 문제 방지

* Transaction에서 발생할 수 있는 **문제들**
```markdown
Dirty Read Problem
- 한 트랜잭션에서 변경한 값을 다른 트랜잭션에서 읽을 때 발생하는 문제
- 이때 변경한 값이 Rollback될 경우 문제 발생

Non-repeatable Read Problem
- 한 트랜잭션에서 같은 값을 두 번 읽었을 때 각각 다른 값이 읽히는 경우

Phantom Read Problem
- 주로 통계나 분석, aggregation function 등을 수행하는 쿼리에서 잘못된 값이 들어오는 경우
- 조회했을 때는 변경 사항이 없었으나, 통계를 낼 때 변경된 값으로 통계가 계산되는 등
```

* Transaction **Isolation Level**
```markdown
Read Uncommitted
- 다른 트랜잭션에서 바꾼 값이 트랜잭션 중간에도 반영
- 다른 값이 읽힐 수 있음. (옳지 않은 값)
- 일반적으로 그냥 최신 업데이트 값을 읽음
- 상당히 위험 
  
Read Committed
- 커밋된 아이템을 읽을 수 있는 모드
- 커밋되지 않은 값은 읽을 수 없음
- 같은 트랜잭션에서는 최근의 스냅샷을 읽음

Repeatable Read
- MySQL의 기본 동작 모드
- 첫 번째 읽기에 스냅샷을 생성
- 이후 동일 트랜잭션에서는 스냅샷에서부터 값을 읽음
- 잠금의 대상은 unique index, secoendary index의 유무에 따라 달라짐


Serializable
- MySQL에서는 모든 SELECT문에 공유락
- Repeatable Read에서도 Phantom 문제가 발생하지 않으므로 많이 사용하지 않음
- 역시나 매우 위험 -> 매우매우 느림
```

* MySQL의 기본 모드는 Repeatable Read이다. 그런데도 MySQL의 Repeatable Read는 팬텀 리드 문제가 발생하지 않는다고 한다.

* transaction의 isolation level은 세션별로도 지정해줄 수 있다.

* MySQL에는 다양한 락의 종류가 있다.

### 강의5
* 중복적으로 사용하는 테스트 데이터는 중복된 코드가 발생하므로 묶어놓는 것을 추천한다.(테스트를 위한 User 객체 등)

* 향로님 -> enum 글 읽어보는거 추천!

* JPA -> java persistence api

* jpa는 인터페이스, hibernate는 구현체, spring data jpa는 jpa를 더 쉽게 사용할 수 있도록 도와주는 도구.

* FK는 선택이다.

* FK를 사용하면 매번 그 대상 table의 pk인덱스를 확인하기 때문에 약간의 성능저하도 생긴다.

* FK를 만들면 인덱스가 자동으로 하나 생긴다.(MySQL에서!)

* MySQL의 visual plan 기능 사용하는거 추천한다. (실행계획을 도식화해서 보여준다!)

* orm을 사용함으로써 데이터 중심 사고에서 좀 더 벗어날 수 있다. 보다 도메인에 집중할 수 있다. 우리가 해결해야할 문제에 집중할 수 있다.

* 최범균님이 쓰신 DDD책 추천한다.

* ORM은 자바 객체와 테이블 매핑을 통해 DB쿼리를 손쉽게 도와주는 프레임워크

## 테스트/실행 방법
### 실행 방법
* "src/main/java/webserver/WebServer.java" 에 있는 main 함수를 실행하여 프로그램을 띄울 수 있습니다.
* 프로그램을 띄운 후, http://localhost:8080/index.html 에 접속하면 메인 페이지를 확인하실 수 있습니다. 
* 회원가입 성공/실패에 따른 쿠키 값은 크롬 개발자 도구의 애플리케이션 쪽에서 확인할 수 있습니다.

### 테스트 방법
* src/test/java 내에서 이 프로젝트 내에 있는 모든 테스트 코드를 확인할 수 있습니다.
* 작성된 테스트 코드를 실행해볼 수 있습니다. intellij를 활용하여 테스트를 모두 묶어서 구성 하면, 더 빠르고 간편하게 전체 테스트를 돌려볼 수 있습니다.
* "hello.http" 를 이용해 몇가지 API를 브라우저 없이도 테스트할 수 있습니다.