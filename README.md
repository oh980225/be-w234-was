# java-was-2022

## Java Web Application Server 2022

### 강의1
* Thread는 각각 별도의 레지스터, Stack을 따로 할당 받는다.

* Thread는 CPU에서 실행되는데, 이 별도의 공간을 이용하여 컨텍스트 스위칭이 가능한 것이다.

* 하지만 Heap Area와 Method Area는 공유하여 사용한다.

* 자바에서 Thread는 메서드 단위로 수행된다.

* 해당 과제에서의 요청 흐름 
  1. 서버 소켓 생성
  2. 서버 소켓 요청 대기
  3. 클라이언트 요청
  4. 커넥션 소켓 생성 (별도의 포트 할당)
  5. 해당 소켓을 통해 클라이언트의 요청을 처리하는 워커 쓰레드 생성
  6. 워커 쓰레드를 통해 작업 수행 및 응답

* 이번 단계를 구현하며 한 생각 정리
  * HttpMethod와 프로토콜은 상수라고 생각하여 enum으로 뽑아내었다.
  * url같은 경우, 상수로 지정하기 어렵고 아직 불변식이라고 할만한 부분이 없어서 우선 String을 사용하였다.
  * String 값에 대해 null 또는 빈 값인 경우, 예외를 발생하게 해놓은 코드는 범용적으로 사용하게 된다면 Util 클래스를 만들어 옮길 것 같다.
  * 웹 서버 동작 중 발생할 수 있는 예외에 대해 Custom Exception class를 만들었다. 각 경우에 대해 따로 클래스를 만들게 되면 상당한 양의 예외 클래스가 생길 것이라 판단하여 하나의 예외 클래스에서 사용되는 다양한 에러 메시지를 Enum으로 사용하도록 하였다.

### 강의2
* 커밋은 작게 원자 단위로 하자! (메서드 단위가 베스트)

* reset은 기록이 안남지만, revert는 기록이 쌓인다! 그렇기에 가능하면 풍부한 기록을 남기는 revert가 더 좋다!

* TDD -> test code를 먼저 짜고 구현 시작!
  * 보통 익숙하지 않으면 코드를 먼저 짜고 테스트 코드를 작성한다.
  * 연습을 위해 위처럼하고 구현 코드를 날려보고, 다시 구현하는 것도 괜찮다.

* Git commit을 이용해서 구현 전에 상세한 커밋을 작성하고, 계획적으로 코딩하는 방법도 있다.

* 주석은 최소한으로! 주석이 없이 이해가 가능한 코드가 더 좋은 코드다!

* UDP는 IP에서 그냥 플러스 알파이다. 대신 속도가 엄청 빠르고, 커스터마이징할 것이 많다.

* 요즘은 그냥 실시간 채팅 같은 경우도 TCP를 사용한다.

* 하지만 TCP 같은 경우는 이거저거 다 붙혀놓아 코스트가 크기 때문에, 속도를 위해 UDP를 기반으로 커스터마이징 해서 사용하기도 한다.
  * HTTP 3 같은 경우에도 UDP를 기반으로 만들 계획이라고 한다.

### 강의3
* MIME -> 클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘. 서버는 각 문서와 함께 올바른 MIME 타입을 보내주는 것이 중요하다.

* 리다이렉트 수행 : 서버에서 302를 준다. -> 브라우저가 리다이렉트를 수행한다.(실제 액션)

* 쿠키 : 서버에서 Set-Cookie를 보내면, 클라이언트에서 쿠키를 만들고 보관 -> 다음 요청부터 쿠키를 요청에 담아서 보낸다.

* 브라우저가 쿠키를 저장하는 방법 : 크롬 같은 경우, 내부적인 조그만 DB에 저장(ex) SQLLite)

* DB 관련
```markdown
- PK는 자동으로 인덱스가 만들어진다.
 
- 인덱스를 통해서 검색속도를 향상시킬 수있다.

- 인덱스는 B+Tree 자료구조를 사용한다.

- B+Tree는 범위 검색에 강하다.

- 테이블은 페이지로 구성되어있다.

- 페이지 내에 레코드들이 쌓여있다. 한 페이지는 보통 16KB로 되어있다.

- 레코드들은 특정 key 값으로 정렬되어있다. (PK 값)

- 클러스터 인덱스 : PK에 대해 B+Tree 인덱스가 구성되어있고 이 B+Tree의 리프노드가 페이지 내에 
  쌓여있는 레코드에 대해 해당하는 데이터 포인터를 가지고 있는 것! 자료구조를 뜻하는 것이 아니다.
  
- 쿼리가 느릴 때 가장 먼저 해볼 수 있는 시도는 인덱스를 만드는 것이다.

- MySQL은 내부적으로 통계 정보를 가지고 있다. 각 데이터가 어느정도 분포되어있는지 알고 있다. 
  이것을 이용해 쿼리 플랜을 세운다.
  
- 왜 인덱스가 있어도 탈 때도 있고, 안 탈때도 있을까? 
  -> 인덱스를 타는 비용은 [인덱스를 찾는 비용 + 각각의 포인터를 통해 원하는 데이터를 찾아가는 비용]이다.
  풀스캔은 [데이터 페이지를 그냥 쭈욱 읽는 비용]이 든다. 그렇기에 인덱스를 탄다고 항상 빠른 것은 아니다!  
  옵티마이저가 각 경우에 대한 비용을 산정하여 가장 효율적인 방식을 고른다. 일반적으로 전체페이지 중 
  20%이상을 검색하면 옵티마이저로 인해 인덱스를 안탄다.(이것이 더 효율적이므로!)
  
- 복합인덱스를 만들때는 컬럼의 순서가 중요하다!
```

## 테스트/실행 방법
### 실행 방법
* "src/main/java/webserver/WebServer.java" 에 있는 main 함수를 실행하여 프로그램을 띄울 수 있습니다.
* 프로그램을 띄운 후, http://localhost:8080/index.html 에 접속하면 메인 페이지를 확인하실 수 있습니다. 
* 회원가입 성공/실패에 따른 쿠키 값은 크롬 개발자 도구의 애플리케이션 쪽에서 확인할 수 있습니다.

### 테스트 방법
* src/test/java 내에서 이 프로젝트 내에 있는 모든 테스트 코드를 확인할 수 있습니다.
* 작성된 테스트 코드를 실행해볼 수 있습니다. intellij를 활용하여 테스트를 모두 묶어서 구성 하면, 더 빠르고 간편하게 전체 테스트를 돌려볼 수 있습니다.
* "hello.http" 를 이용해 몇가지 API를 브라우저 없이도 테스트할 수 있습니다.